SWAP16 and SWAP32 operations are fundamentally designed to work on numeric types, specifically integers.

SWAP instructions are low-level CPU operations. They don't care about the type of data (e.g., int, float, char). They only operate on the raw binary bits and bytes. A SWAP32 instruction, for instance, just takes 32 bits from a register or memory location and rearranges them in a specific order.
The reason we say they "only accept number types" is because that's the only context in which the operation is semantically useful. If you were to apply a SWAP32 to a 32-bit block of memory containing a mix of data (e.g., a string or part of an image), the result would be a scrambled mess.

-------------------------------------------------------------
The "High-Level" View: The value of the integer, as you see it in a debugger or in your code. This is the abstract concept of the number, typically written in big-endian order for human readability.
The "Low-Level" View: The physical representation of the bytes in memory, at specific addresses. This is where endianness truly manifests.
==============================================================
SWAP32 Example

Let's say we have an unsigned 32-bit integer variable my_value.
Initial State:
my_value is assigned the value 0xABCDEF12.
High-Level View: my_value = 0xABCDEF12

Memory Layout (little-endian system):
Memory Address A: 12
Memory Address A+1: EF
Memory Address A+2: CD
Memory Address A+3: AB

SWAP32 Operation (using htonl)
my_value is passed to the htonl function, which performs a SWAP32 operation.
The function returns a new value, which we store in network_value.

Final State:
High-Level View: network_value = 0x12EFCDAB
Memory Layout (little-endian system) of network_value:
Memory Address B: AB
Memory Address B+1: CD
Memory Address B+2: EF
Memory Address B+3: 12

This is the correct representation. The SWAP32 instruction changes the value of the number, which in turn changes how the bytes are laid out in memory according to the system's endianness. The key is that the "before" and "after" memory layouts correspond to two different numbers.
==============================================================
Where Byte Swapping is Needed
Primarily for interoperability between different computer systems. The need arises because different systems have different conventions for how they store multi-byte data types like integers and floating-point numbers. This convention is known as endianness.

There are two main types of endianness:
Little-Endian: The least significant byte (LSB) is stored at the lowest memory address. Most modern consumer systems, like those with Intel x86 or AMD processors, are little-endian.
Big-Endian: The most significant byte (MSB) is stored at the lowest memory address. This is the convention used by many older systems (like Motorola processors) and, crucially, by many network protocols.

1) The Conflict: Network vs. Host Byte Order
The main reason for byte swapping is to resolve the conflict between a computer's "host byte order" and the "network byte order."
Host Byte Order: The endianness of your specific computer (e.g., little-endian on a typical PC).
Network Byte Order: The standardized byte order for communication over a network. The Internet's core protocols, like TCP/IP, universally use big-endian.

This means that if a little-endian machine wants to send a multi-byte integer (like an IP address or a port number) over the network, it must first convert it to big-endian format. The receiving machine, regardless of its own endianness, will receive the data in big-endian format. If the receiving machine is little-endian, it must then perform a byte swap to convert the data back to its native format before it can use it.

2) Other Scenarios Where Byte Swapping is Needed
The network communication example is the most common, but byte swapping is also necessary in other situations:
File Formats: Many binary file formats (e.g., image formats, data archives) specify a particular byte order. If you're reading a file created on a big-endian machine on your little-endian machine, you may need to swap the bytes to correctly interpret the data.
Cross-Platform Development: When writing code that needs to run on different platforms with varying endianness, you must account for these differences. Using byte swap functions ensures your code will work correctly on all target architectures.
Embedded Systems: Microcontrollers and other embedded systems may use a different endianness than the host computer they are communicating with, necessitating byte swapping.

In essence, byte swapping is a crucial step for data serialization and deserialization whenever data is transferred between different systems or stored in a way that needs to be interpreted consistently across different architectures. It's a low-level operation that ensures the integrity and correctness of multi-byte data as it moves between different "worlds" with different internal conventions
